// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4680.Dash2019.subsystems;

import org.usfirst.frc4680.Dash2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;

import java.util.function.DoublePredicate;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Arm extends Subsystem {

    public static final double Kp = 0.01;
    public static final double Ki = 0.0;
    public static final double Kd = 0.0;
    public static final double Kf = 0.1;

    //TODO calibrate this start angle.
    //Zero is with the arm straight horizontal
    public static final double MINIMUM_ANGLE = -30.0;
    public static final double MAXIMUM_ANGLE = 100.0;
    public static final double ANGLE_TOLERANCE = 3.0;
    private static final double degreesPerEncoderCount = (360.0 / 4096) * (12/60); 

    private PIDSourceTalon pivotMotorA;
    private WPI_TalonSRX pivotMotorB;

    private VerticalArmPIDController m_controller;


    public Arm() {
       
        pivotMotorA = new PIDSourceTalon(4);
        pivotMotorA.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, 10);
        pivotMotorA.getSensorCollection().setQuadraturePosition(0, 10);
 
        // NO ENCODER CONNECTED
        pivotMotorB = new WPI_TalonSRX(5);
        pivotMotorB.follow(pivotMotorA);        
        
        m_controller = new VerticalArmPIDController(Kp, Ki, Kd, Kf, pivotMotorA, pivotMotorA);
        m_controller.setOutputRange(MINIMUM_ANGLE, MAXIMUM_ANGLE);
        m_controller.setAbsoluteTolerance(ANGLE_TOLERANCE);
    }

    @Override
    public void initDefaultCommand() {
        setDefaultCommand(new ManualArmControl());
    }

    @Override
    public void periodic() {
        SmartDashboard.putNumber("Arm Angle", getAngle());
        SmartDashboard.putBoolean("Arm PID On", m_controller.isEnabled());
    }


    public void enablePID(boolean flag) {
        if(flag && !m_controller.isEnabled()) {
            m_controller.setSetpoint( getAngle());
            m_controller.enable();
        }

        if(!flag && m_controller.isEnabled()) {
            m_controller.disable();
        }
    }


    public double getAngle() {
        return pivotMotorA.getAngle();
    }

    public void moveShoulder(double speed) {
        if(m_controller.isEnabled()) {
            double setpoint = m_controller.getSetpoint();
            setpoint += (speed / 10);
            m_controller.setSetpoint(setpoint);
        } else {
            pivotMotorA.set(speed);
        }
    }

    public void stop() {
        pivotMotorA.stopMotor();
    }

    public class PIDSourceTalon extends WPI_TalonSRX implements PIDSource {
        @Override
        public PIDSourceType getPIDSourceType() {
            return PIDSourceType.kDisplacement;
        }

        @Override
        public double pidGet() {
            return getAngle();
        }

        @Override
        public void setPIDSourceType(PIDSourceType pidSource) {
            // do nothing
        }

        PIDSourceTalon(int CANid) {
            super(CANid);
        }

        public double getAngle() {
            int quadraturePosition = getSensorCollection().getQuadraturePosition();
            return (quadraturePosition * degreesPerEncoderCount) + MINIMUM_ANGLE;
        }   
    }


    public class VerticalArmPIDController extends PIDController {
        VerticalArmPIDController(double p, double i, double d, double f, PIDSource src, PIDOutput out) {
            super(p, i, d, f, src, out);
        }

        @Override
        protected double calculateFeedForward() {
            return getF() * Math.cos(Math.toRadians(getAngle()));
        }
    }

}

